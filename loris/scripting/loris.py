# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""

Loris is an Open Source sound modeling and processing software package
based on the Reassigned Bandwidth-Enhanced Additive Sound Model. Loris
supports modified resynthesis and manipulations of the model data,
such as time- and frequency-scale modification and sound morphing.


Loris is developed by Kelly Fitz and Lippold Haken at the CERL Sound
Group, and is distributed under the GNU General Public License (GPL).
For more information, please visit

   http://www.cerlsoundgroup.org/Loris/

"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _loris
else:
    import _loris

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_SwigPyIterator

    def value(self):
        return _loris.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _loris.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _loris.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _loris.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _loris.SwigPyIterator_equal(self, x)

    def copy(self):
        return _loris.SwigPyIterator_copy(self)

    def next(self):
        return _loris.SwigPyIterator_next(self)

    def __next__(self):
        return _loris.SwigPyIterator___next__(self)

    def previous(self):
        return _loris.SwigPyIterator_previous(self)

    def advance(self, n):
        return _loris.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _loris.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _loris.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _loris.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _loris.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _loris.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _loris.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _loris:
_loris.SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _loris.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _loris.DoubleVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _loris.DoubleVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< double >::size_type"""
        return _loris.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> DoubleVector"""
        return _loris.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _loris.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _loris.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _loris.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> DoubleVector
        __getitem__(self, i) -> std::vector< double >::value_type const &
        """
        return _loris.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _loris.DoubleVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< double >::value_type"""
        return _loris.DoubleVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _loris.DoubleVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _loris.DoubleVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< double >::size_type"""
        return _loris.DoubleVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _loris.DoubleVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< double >::iterator"""
        return _loris.DoubleVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< double >::iterator"""
        return _loris.DoubleVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _loris.DoubleVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< double >::reverse_iterator"""
        return _loris.DoubleVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _loris.DoubleVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< double >::allocator_type"""
        return _loris.DoubleVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _loris.DoubleVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< double >::iterator
        erase(self, first, last) -> std::vector< double >::iterator
        """
        return _loris.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> DoubleVector
        __init__(self, other) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        _loris.DoubleVector_swiginit(self, _loris.new_DoubleVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _loris.DoubleVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< double >::value_type const &"""
        return _loris.DoubleVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< double >::value_type const &"""
        return _loris.DoubleVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _loris.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _loris.DoubleVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< double >::iterator
        insert(self, pos, n, x)
        """
        return _loris.DoubleVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _loris.DoubleVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< double >::size_type"""
        return _loris.DoubleVector_capacity(self)
    __swig_destroy__ = _loris.delete_DoubleVector

# Register DoubleVector in _loris:
_loris.DoubleVector_swigregister(DoubleVector)

class MarkerVector(object):
    r"""Proxy of C++ std::vector< Marker > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _loris.MarkerVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _loris.MarkerVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _loris.MarkerVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< Marker >::size_type"""
        return _loris.MarkerVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> MarkerVector"""
        return _loris.MarkerVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _loris.MarkerVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _loris.MarkerVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _loris.MarkerVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> MarkerVector
        __getitem__(self, i) -> Marker
        """
        return _loris.MarkerVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _loris.MarkerVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Marker"""
        return _loris.MarkerVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _loris.MarkerVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _loris.MarkerVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< Marker >::size_type"""
        return _loris.MarkerVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _loris.MarkerVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< Marker >::iterator"""
        return _loris.MarkerVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< Marker >::iterator"""
        return _loris.MarkerVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< Marker >::reverse_iterator"""
        return _loris.MarkerVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< Marker >::reverse_iterator"""
        return _loris.MarkerVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _loris.MarkerVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< Marker >::allocator_type"""
        return _loris.MarkerVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _loris.MarkerVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< Marker >::iterator
        erase(self, first, last) -> std::vector< Marker >::iterator
        """
        return _loris.MarkerVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> MarkerVector
        __init__(self, other) -> MarkerVector
        __init__(self, size) -> MarkerVector
        __init__(self, size, value) -> MarkerVector
        """
        _loris.MarkerVector_swiginit(self, _loris.new_MarkerVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _loris.MarkerVector_push_back(self, x)

    def front(self):
        r"""front(self) -> Marker"""
        return _loris.MarkerVector_front(self)

    def back(self):
        r"""back(self) -> Marker"""
        return _loris.MarkerVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _loris.MarkerVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _loris.MarkerVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< Marker >::iterator
        insert(self, pos, n, x)
        """
        return _loris.MarkerVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _loris.MarkerVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< Marker >::size_type"""
        return _loris.MarkerVector_capacity(self)
    __swig_destroy__ = _loris.delete_MarkerVector

# Register MarkerVector in _loris:
_loris.MarkerVector_swigregister(MarkerVector)


def channelize(*args):
    r"""
    channelize(partials, refFreqEnvelope, refLabel)
    channelize(partials, refFreq)
    Label Partials in a PartialList with the integer nearest to the
    amplitude-weighted average ratio of their frequency envelope to a
    reference frequency envelope. If a reference frequency is specified,
    then the reference envelope is constant at that frequency.

    The frequency spectrum is partitioned into non-overlapping channels
    whose time-varying center frequencies track the reference frequency
    envelope. The reference label indicates which channel's center
    frequency is exactly equal to the reference envelope frequency, and
    other channels' center frequencies are multiples of the reference
    envelope frequency divided by the reference label. Each Partial in the
    PartialList is labeled with the number of the channel that best fits
    its frequency envelope. Partials are labeled, but otherwise
    unmodified.

    For finer control over channelization, including harmonic stretching
    for stiff strings, and amplitude weighting for determining the
    best-fitting channel, use the Channelizer class.
    """
    return _loris.channelize(*args)

def collate(*args):
    r"""
    collate(partials, fadeTime=Collator::DefaultFadeTimeMs/1000.0, gapTime=Collator::DefaultSilentTimeMs/1000.0)
    Collate unlabeled (zero-labeled) Partials into the smallest-possible 
    number of Partials that does not combine any overlapping Partials.
    Collated Partials assigned labels higher than any label in the original 
    list, and appear at the end of the sequence, after all previously-labeled
    Partials. Optionally specify the fade and gap times, else default values
    are used.
    """
    return _loris.collate(*args)

def createFreqReference(*args):
    r"""
    createFreqReference(partials, minFreq, maxFreq, numSamps) -> LinearEnvelope
    createFreqReference(partials, minFreq, maxFreq) -> LinearEnvelope
    Return a newly-constructed LinearEnvelope using the legacy 
    FrequencyReference class. The envelope will have approximately
    the specified number of samples. The specified number of samples 
    must be greater than 1. Uses the FundamentalEstimator 
    (FundamentalFromPartials) class to construct an estimator of 
    fundamental frequency, configured to emulate the behavior of
    the FrequencyReference class in Loris 1.4-1.5.2. If numSamps
    is unspecified, construct the reference envelope from fundamental 
    estimates taken every five milliseconds.

    For simple sounds, this frequency reference may be a 
    good first approximation to a reference envelope for
    channelization (see channelize()).
    """
    return _loris.createFreqReference(*args)

def createF0Estimate(partials, minFreq, maxFreq, interval):
    r"""
    createF0Estimate(partials, minFreq, maxFreq, interval) -> LinearEnvelope
    Return a newly-constructed LinearEnvelope that estimates
    the time-varying fundamental frequency of the sound
    represented by the Partials in a PartialList. This uses
    the FundamentalEstimator (FundamentalFromPartials) 
    class to construct an estimator of fundamental frequency, 
    and returns a LinearEnvelope that samples the estimator at the 
    specified time interval (in seconds). Default values are used 
    to configure the estimator. Only estimates in the specified 
    frequency range will be considered valid, estimates outside this 
    range will be ignored.

    Clients are responsible for disposing of the newly-constructed 
    LinearEnvelope.
    """
    return _loris.createF0Estimate(partials, minFreq, maxFreq, interval)

def dilate(partials, ivec, tvec):
    r"""
    dilate(partials, ivec, tvec)
    Dilate Partials in a PartialList according to the given initial
    and target time points. Partial envelopes are stretched and
    compressed so that temporal features at the initial time points
    are aligned with the final time points. Time points are sorted, so
    Partial envelopes are are only stretched and compressed, but
    breakpoints are not reordered. Duplicate time points are allowed.
    There must be the same number of initial and target time points.
    """
    return _loris.dilate(partials, ivec, tvec)

def distill(*args):
    r"""
    distill(partials, fadeTime=Distiller::DefaultFadeTimeMs/1000.0, gapTime=Distiller::DefaultSilentTimeMs/1000.0)
    Distill labeled (channelized) Partials in a PartialList into a 
    PartialList containing at most one Partial per label. Unlabeled 
    (zero-labeled) Partials are left unmodified at the end of the 
    distilled Partials. Optionally specify the fade and gap times, 
    defaults are 5ms and 1ms.

    """
    return _loris.distill(*args)

def exportAiff(*args):
    r"""
    exportAiff(path, samples, samplerate=44100, bitsPerSamp=16, nchansignored=1)
    exportAiff(path, partials, samplerate=44100, bitsPerSamp=16)
    Export audio samples stored in a vector to an AIFF file having the
    specified number of channels and sample rate at the given file
    path (or name). The floating point samples in the vector are
    clamped to the range (-1.,1.) and converted to integers having
    bitsPerSamp bits. The default values for the sample rate and
    sample size, if unspecified, are 44100 Hz (CD quality) and 16 bits
    per sample, respectively. If neither is specified, then the 
    default synthesis parameters (see SynthesisParameters) are used.

    If a PartialList is specified, the Partials are rendered at the
    specified sample rate and then exported.

    Only mono files can be exported, the last argument is ignored, 
    and is included only for backward compatability
    """
    return _loris.exportAiff(*args)

def exportSdif(path, partials):
    r"""
    exportSdif(path, partials)
    Export Partials in a PartialList to a SDIF file at the specified
    file path (or name). SDIF data is written in the Loris RBEP
    format. For more information about SDIF, see the SDIF website at:
    	www.ircam.fr/equipes/analyse-synthese/sdif/  
    """
    return _loris.exportSdif(path, partials)

def exportSpc(*args):
    r"""
    exportSpc(path, partials, midiPitch, enhanced, endApproachTime)
    exportSpc(path, partials, midiPitch, enhanced)
    exportSpc(path, partials, midiPitch)
    Export Partials in a PartialList to a Spc file at the specified
    file path (or name). The fractional MIDI pitch must be specified.
    The optional enhanced parameter defaults to true (for
    bandwidth-enhanced spc files), but an be specified false for
    pure-sines spc files. The optional endApproachTime parameter is in
    seconds; its default value is zero (and has no effect). A nonzero
    endApproachTime indicates that the PartialList does not include a
    release, but rather ends in a static spectrum corresponding to the
    final breakpoint values of the partials. The endApproachTime
    specifies how long before the end of the sound the amplitude,
    frequency, and bandwidth values are to be modified to make a
    gradual transition to the static spectrum.
    """
    return _loris.exportSpc(*args)

def harmonify(*args):
    r"""
    harmonify(partials, refLabel, env, threshold_dB)
    harmonify(partials, refLabel, threshold_dB)
    Apply a reference Partial to fix the frequencies of Breakpoints
    whose amplitude is below threshold_dB. Threshold 0 harmonifies all
    Partials. To apply only to quiet Partials, specify a lower 
    threshold (like -90). The reference Partial is the first Partial
    in the PartialList labeled refLabel (usually 1). The Envelope,
    if specified, is a time-varying weighting on the harmonifing process. 
    When 1, harmonic frequencies are used, when 0, breakpoint frequencies are 
    unmodified. 
    """
    return _loris.harmonify(*args)

def importSdif(path):
    r"""
    importSdif(path) -> PartialList
    Import Partials from an SDIF file at the given file path (or
    name), and return them in a PartialList. Loris can import
    SDIF data stored in 1TRC format or in the Loris RBEP format.
    For more information about SDIF, see the SDIF website at:
    	www.ircam.fr/equipes/analyse-synthese/sdif/
    """
    return _loris.importSdif(path)

def importSpc(path):
    r"""
    importSpc(path) -> PartialList
    Import Partials from an Spc file at the given file path (or
    name), and return them in a PartialList.
    """
    return _loris.importSpc(path)

def enableLogAmpMorphing(enableFlag):
    r"""
    enableLogAmpMorphing(enableFlag)
    Enable or disable log-domain amplitude and bandwidth morphing.
    """
    return _loris.enableLogAmpMorphing(enableFlag)

def enableLogFreqMorphing(enableFlag):
    r"""
    enableLogFreqMorphing(enableFlag)
    Enable or disable log-domain frequency morphing.
    """
    return _loris.enableLogFreqMorphing(enableFlag)

def morph(*args):
    r"""
    morph(src0, src1, ffreq, famp, fbw) -> PartialList
    morph(src0, src1, freqweight, ampweight, bwweight) -> PartialList
    morph(src0, src1, src0RefLabel, src1RefLabel, ffreq, famp, fbw) -> PartialList
    morph(src0, src1, src0RefLabel, src1RefLabel, freqweight, ampweight, bwweight) -> PartialList
    Morph labeled Partials in two PartialLists according to the
    given frequency, amplitude, and bandwidth (noisiness) morphing
    envelopes, and return the morphed Partials in a PartialList.

    Optionally specify the labels of the Partials to be used as 
    reference Partial for the two morph sources. The reference 
    partial is used to compute frequencies for very low-amplitude 
    Partials whose frequency estimates are not considered reliable. 
    The reference Partial is considered to have good frequency 
    estimates throughout. A reference label of 0 indicates that 
    no reference Partial should be used for the corresponding
    morph source.

    Loris morphs Partials by interpolating frequency, amplitude,
    and bandwidth envelopes of corresponding Partials in the
    source PartialLists. For more information about the Loris
    morphing algorithm, see the Loris website:
    	www.cerlsoundgroup.org/Loris/
    """
    return _loris.morph(*args)

def setAmplitudeMorphShape(shape):
    r"""
    setAmplitudeMorphShape(shape)
    Set the shaping parameter for the amplitude morphing
    function. 

    DEPRECATED - DO NOT USE

    """
    return _loris.setAmplitudeMorphShape(shape)

def crop(partials, t1, t2):
    r"""
    crop(partials, t1, t2)
    Trim Partials by removing Breakpoints outside a specified time span.
    Insert a Breakpoint at the boundary when cropping occurs.

    """
    return _loris.crop(partials, t1, t2)

def copyLabeled(partials, label):
    r"""
    copyLabeled(partials, label) -> PartialList
    Copy Partials in the source PartialList having the specified label
    into a new PartialList. The source PartialList is unmodified.

    """
    return _loris.copyLabeled(partials, label)

def extractLabeled(partials, label):
    r"""
    extractLabeled(partials, label) -> PartialList
    Extract Partials in the source PartialList having the specified
    label and return them in a new PartialList.
    """
    return _loris.extractLabeled(partials, label)

def removeLabeled(partials, label):
    r"""
    removeLabeled(partials, label)
    Remove from a PartialList all Partials having the specified label.
    """
    return _loris.removeLabeled(partials, label)

def resample(*args):
    r"""
    resample(partials, interval, denseResampling=True, phaseCorrect=True)
    resample(partials, timing, interval, phaseCorrect=False)
    Resample all Partials in a PartialList using the specified
    sampling interval, so that the Breakpoints in the Partial
    envelopes will all lie on a common temporal grid. 

    The Breakpoint times in resampled Partials will comprise a
    contiguous sequence of ALL integer multiples of the sampling interval
    (a lot of data, but useful for some third-party tools, like the CNMAT
    sinusoids~ external for Max/MSP). 

    If a timing envelope is specified, then that envelope represents
    a warping of the time axis that is applied during resampling. The
    Breakpoint times in resampled Partials will a comprise contiguous 
    sequence of all integer multiples of the sampling interval between 
    the first and last breakpoints in the timing envelope, and each 
    Breakpoint will represent the parameters of the original Partial 
    at the time that is the value of the timing envelope at that instant.
    This can be used to achieve effects similar to dilation (see dilate),
    but can also be used to achieve time-reveral and scrubbing effects.

    If phase correct resampling is selected, Partial frequencies are
    altered slightly to match, as nearly as possible, the Breakpoint
    phases after resampling. Phases are updated so that the Partial
    frequencies and phases are consistent after resampling. The
    default is phase correct resampling, unless a timing envelope
    is specified, in which case it is better to explcitly match
    phases at known critical points.

    See also quantize, which was previously described as sparse
    resampling.
    """
    return _loris.resample(*args)

def quantize(partials, interval):
    r"""
    quantize(partials, interval)
    Quantize the Breakpoint times in the specified Partials.
    Each Breakpoint in the Partials is replaced by a Breakpoint
    constructed by resampling the Partial at the nearest
    integer multiple of the of the resampling interval.

    In previous versions of Loris, this was called sparse resampling.

    """
    return _loris.quantize(partials, interval)

def scaleAmp(*args):
    r"""
    scaleAmp(partials, ampEnv)
    scaleAmp(partials, val)
    Bad old name for scaleAmplitude.
    """
    return _loris.scaleAmp(*args)

def scaleAmplitude(*args):
    r"""
    scaleAmplitude(partials, ampEnv)
    scaleAmplitude(p, ampEnv)
    scaleAmplitude(partials, val)
    scaleAmplitude(p, val)
    Scale the amplitude of a Partial, or all Partials in a PartialList, according 
    to an envelope representing a time-varying amplitude scale value.
    """
    return _loris.scaleAmplitude(*args)

def scaleBandwidth(*args):
    r"""
    scaleBandwidth(partials, bwEnv)
    scaleBandwidth(partials, val)
    scaleBandwidth(p, bwEnv)
    scaleBandwidth(p, val)
    Scale the bandwidth of a Partial, or all Partials in a PartialList, according 
    to an envelope representing a time-varying bandwidth scale value.
    """
    return _loris.scaleBandwidth(*args)

def scaleFrequency(*args):
    r"""
    scaleFrequency(partials, freqEnv)
    scaleFrequency(partials, val)
    scaleFrequency(p, freqEnv)
    scaleFrequency(p, val)
    Scale the frequency of a Partial, or all Partials in a PartialList, according 
    to an envelope representing a time-varying frequency scale value.
    """
    return _loris.scaleFrequency(*args)

def scaleNoiseRatio(*args):
    r"""
    scaleNoiseRatio(partials, noiseEnv)
    scaleNoiseRatio(partials, val)
    scaleNoiseRatio(p, noiseEnv)
    scaleNoiseRatio(p, val)
    Scale the relative noise content of a Partial, or all Partials in a PartialList,
    according to an envelope representing a (time-varying) noise energy 
    scale value.
    """
    return _loris.scaleNoiseRatio(*args)

def setBandwidth(*args):
    r"""
    setBandwidth(partials, bwEnv)
    setBandwidth(partials, val)
    setBandwidth(p, bwEnv)
    setBandwidth(p, val)
    Set the bandwidth of a Partial, or all Partials in a PartialList, according 
    to an envelope representing a time-varying bandwidth value.
    """
    return _loris.setBandwidth(*args)

def shapeSpectrum(*args):
    r"""
    shapeSpectrum(partials, surface, stretchFreq, stretchTime)
    shapeSpectrum(partials, surface)
    Scale the amplitudes of a set of Partials by applying 
    a spectral suface constructed from another set.
    If frequency and time stretch factors are specified,
    then the spectral surface is stretched by those 
    factors before the surface is used to shape the 
    Partial amplitudes.
    """
    return _loris.shapeSpectrum(*args)

def shiftPitch(*args):
    r"""
    shiftPitch(partials, pitchEnv)
    shiftPitch(partials, val)
    Shift the pitch of all Partials in a PartialList according to 
    the given pitch envelope. The pitch envelope is assumed to have 
    units of cents (1/100 of a halfstep).
    """
    return _loris.shiftPitch(*args)

def shiftTime(partials, offset):
    r"""
    shiftTime(partials, offset)
    Shift the time of all the Breakpoints in a Partial by a constant
    amount (in seconds).
    """
    return _loris.shiftTime(partials, offset)

def sift(*args):
    r"""
    sift(partials, fadeTime=Sieve::DefaultFadeTimeMs/1000.0)
    Eliminate overlapping Partials having the same label
    (except zero). If any two partials with same label
    overlap in time, keep only the longer of the two.
    Set the label of the shorter duration partial to zero.
    Optionally specify the fade time, default is 1ms.
    """
    return _loris.sift(*args)

def sortByLabel(partials):
    r"""
    sortByLabel(partials)
    Sort the Partials in a PartialList in order of increasing label.
    The sort is stable; Partials having the same label are not
    reordered.
    """
    return _loris.sortByLabel(partials)

def avgAmplitude(p):
    r"""
    avgAmplitude(p) -> double
    Return the average amplitude over all Breakpoints in this Partial.
    Return zero if the Partial has no Breakpoints.
    """
    return _loris.avgAmplitude(p)

def avgFrequency(p):
    r"""
    avgFrequency(p) -> double
    Return the average frequency over all Breakpoints in this Partial.
    Return zero if the Partial has no Breakpoints.
    """
    return _loris.avgFrequency(p)

def peakAmplitude(p):
    r"""
    peakAmplitude(p) -> double
    Return the maximum amplitude achieved by a Partial.
    """
    return _loris.peakAmplitude(p)

def timeSpan(partials):
    r"""
    timeSpan(partials)
    Return the minimum start time and maximum end time
    of all Partials in this PartialList.
    """
    return _loris.timeSpan(partials)

def weightedAvgFrequency(p):
    r"""
    weightedAvgFrequency(p) -> double
    Return the average frequency over all Breakpoints in this Partial, 
    weighted by the Breakpoint amplitudes. Return zero if the Partial 
    has no Breakpoints.
    """
    return _loris.weightedAvgFrequency(p)

def fixPhaseAfter(partials, time):
    r"""
    fixPhaseAfter(partials, time)
    Recompute phases of all Breakpoints later than the specified 
    time so that the synthesized phases of those later Breakpoints 
    matches the stored phase, as long as the synthesized phase at 
    the specified time matches the stored (not recomputed) phase.

    Phase fixing is only applied to non-null (nonzero-amplitude) 
    Breakpoints, because null Breakpoints are interpreted as phase 
    reset points in Loris. If a null is encountered, its phase is 
    corrected from its non-Null successor, if it has one, otherwise 
    it is unmodified.
    """
    return _loris.fixPhaseAfter(partials, time)

def fixPhaseAt(partials, time):
    r"""
    fixPhaseAt(partials, time)
    Recompute phases of all Breakpoints in a Partial
    so that the synthesized phases match the stored phases, 
    and the synthesized phase at (nearest) the specified
    time matches the stored (not recomputed) phase.

    Backward phase-fixing stops if a null (zero-amplitude) 
    Breakpoint is encountered, because nulls are interpreted as 
    phase reset points in Loris. If a null is encountered, the 
    remainder of the Partial (the front part) is fixed in the 
    forward direction, beginning at the start of the Partial. 
    Forward phase fixing is only applied to non-null 
    (nonzero-amplitude) Breakpoints. If a null is encountered, 
    its phase is corrected from its non-Null successor, if 
    it has one, otherwise it is unmodified.
    """
    return _loris.fixPhaseAt(partials, time)

def fixPhaseBefore(partials, time):
    r"""
    fixPhaseBefore(partials, time)
    Recompute phases of all Breakpoints earlier than the specified 
    time so that the synthesized phases of those earlier Breakpoints 
    matches the stored phase, and the synthesized phase at the 
    specified time matches the stored (not recomputed) phase.

    Backward phase-fixing stops if a null (zero-amplitude) Breakpoint
    is encountered, because nulls are interpreted as phase reset 
    points in Loris. If a null is encountered, the remainder of the 
    Partial (the front part) is fixed in the forward direction, 
    beginning at the start of the Partial.
    """
    return _loris.fixPhaseBefore(partials, time)

def fixPhaseBetween(partials, tbeg, tend):
    r"""
    fixPhaseBetween(partials, tbeg, tend)
    Fix the phase travel between two times by adjusting the
    frequency and phase of Breakpoints between those two times.

    This algorithm assumes that there is nothing interesting 
    about the phases of the intervening Breakpoints, and modifies 
    their frequencies as little as possible to achieve the correct 
    amount of phase travel such that the frequencies and phases at 
    the specified times match the stored values. The phases of all 
    the Breakpoints between the specified times are recomputed.
    """
    return _loris.fixPhaseBetween(partials, tbeg, tend)

def fixPhaseForward(partials, tbeg, tend):
    r"""
    fixPhaseForward(partials, tbeg, tend)
    Recompute phases of all Breakpoints later than the specified 
    time so that the synthesized phases of those later Breakpoints 
    matches the stored phase, as long as the synthesized phase at 
    the specified time matches the stored (not recomputed) phase. 
    Breakpoints later than tend are unmodified.

    Phase fixing is only applied to non-null (nonzero-amplitude) 
    Breakpoints, because null Breakpoints are interpreted as phase 
    reset points in Loris. If a null is encountered, its phase is 
    corrected from its non-Null successor, if it has one, otherwise 
    it is unmodified.
    """
    return _loris.fixPhaseForward(partials, tbeg, tend)

def version():
    r"""
    version() -> char const *
    Return a string describing the Loris version number.
    """
    return _loris.version()
class Marker(object):
    r"""
    Class Marker represents a labeled time point in a set of Partials
    or a vector of samples. Collections of Markers (see the MarkerContainer
    definition below) are held by the File I/O classes in Loris (AiffFile,
    SdifFile, and SpcFile) to identify temporal features in imported
    and exported data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> Marker
        __init__(self, t, s) -> Marker
        __init__(self, other) -> Marker
        Initialize a Marker with the specified time (in seconds) and name,
        or copy the time and name from another Marker. If unspecified, time 
        is zero and the label is empty.
        """
        _loris.Marker_swiginit(self, _loris.new_Marker(*args))
    __swig_destroy__ = _loris.delete_Marker

    def name(self):
        r"""
        name(self) -> char const *
        Return the name of this Marker.
        """
        return _loris.Marker_name(self)

    def time(self):
        r"""
        time(self) -> double
        Return the time (in seconds) associated with this Marker.
        """
        return _loris.Marker_time(self)

    def setName(self, s):
        r"""
        setName(self, s)
        Set the name of the Marker.
        """
        return _loris.Marker_setName(self, s)

    def setTime(self, t):
        r"""
        setTime(self, t)
        Set the time (in seconds) associated with this Marker.
        """
        return _loris.Marker_setTime(self, t)

# Register Marker in _loris:
_loris.Marker_swigregister(Marker)
cvar = _loris.cvar
LORIS_DEFAULT_AMPMORPHSHAPE = cvar.LORIS_DEFAULT_AMPMORPHSHAPE
LORIS_LINEAR_AMPMORPHSHAPE = cvar.LORIS_LINEAR_AMPMORPHSHAPE

class AiffFile(object):
    r"""
    An AiffFile represents a sample file (on disk) in the Audio Interchange
    File Format. The file is read from disk and the samples stored in memory
    upon construction of an AiffFile instance. The samples are accessed by 
    the samples() method, which converts them to double precision floats and
    returns them in a vector.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, filename) -> AiffFile
        __init__(self, vec, samplerate) -> AiffFile
        __init__(self, vec_left, vec_right, samplerate) -> AiffFile
        __init__(self, l, sampleRate=44100, fadeTime=.001) -> AiffFile
        An AiffFile instance can be initialized in any of the following ways:

        Initialize a new AiffFile from a vector of samples and sample rate.

        Initialize a new AiffFile from two vectors of samples, for left and right
        channels, and sample rate.

        Initialize a new AiffFile using data read from a named file.

        Initialize an instance of AiffFile having the specified sample 
        rate, accumulating samples rendered at that sample rate from
        all Partials in the specified PartialList with the (optionally) 
        specified Partial fade time (see Synthesizer.h for an explanation 
        of fade time). 

        """
        _loris.AiffFile_swiginit(self, _loris.new_AiffFile(*args))
    __swig_destroy__ = _loris.delete_AiffFile

    def sampleRate(self):
        r"""
        sampleRate(self) -> double
        Return the sample rate in Hz for this AiffFile.
        """
        return _loris.AiffFile_sampleRate(self)

    def midiNoteNumber(self):
        r"""
        midiNoteNumber(self) -> double
        Return the MIDI note number for this AiffFile. The defaul
        note number is 60, corresponding to middle C.
        """
        return _loris.AiffFile_midiNoteNumber(self)

    def sampleFrames(self):
        r"""
        sampleFrames(self) -> unsigned long
        Return the number of sample frames (equal to the number of samples
        in a single channel file) stored by this AiffFile.
        """
        return _loris.AiffFile_sampleFrames(self)

    def addPartial(self, p, fadeTime=.001):
        r"""
        addPartial(self, p, fadeTime=.001)
        Render the specified Partial using the (optionally) specified
        Partial fade time, and accumulate the resulting samples into
        the sample vector for this AiffFile.
        """
        return _loris.AiffFile_addPartial(self, p, fadeTime)

    def setMidiNoteNumber(self, nn):
        r"""
        setMidiNoteNumber(self, nn)
        Set the fractional MIDI note number assigned to this AiffFile. 
        If the sound has no definable pitch, use note number 60.0 
        (the default).
        """
        return _loris.AiffFile_setMidiNoteNumber(self, nn)

    def write(self, filename, bps=16):
        r"""
        write(self, filename, bps=16)
        Export the sample data represented by this AiffFile to
        the file having the specified filename or path. Export
        signed integer samples of the specified size, in bits
        (8, 16, 24, or 32).
        """
        return _loris.AiffFile_write(self, filename, bps)

    def samples(self):
        r"""
        samples(self) -> DoubleVector
        Return a copy of the samples (as floating point numbers
        on the range -1,1) stored in this AiffFile.
        """
        return _loris.AiffFile_samples(self)

    def channels(self):
        r"""
        channels(self) -> int
        The number of channels is always 1. 
        Loris only deals in mono AiffFiles
        """
        return _loris.AiffFile_channels(self)

    def addPartials(self, l, fadeTime=0.001):
        r"""
        addPartials(self, l, fadeTime=0.001)
        Render all Partials on the specified half-open (STL-style) range
        with the (optionally) specified Partial fade time (see Synthesizer.h
        for an examplanation of fade time), and accumulate the resulting 
        samples.
        """
        return _loris.AiffFile_addPartials(self, l, fadeTime)

    def markers(self):
        r"""
        markers(self) -> MarkerVector
        Return the (possibly empty) collection of Markers for 
        this AiffFile.
        """
        return _loris.AiffFile_markers(self)

    def addMarkers(self, markers):
        r"""
        addMarkers(self, markers)
        Append a collection of Markers for to the existing
        set of Markers for this AiffFile.
        """
        return _loris.AiffFile_addMarkers(self, markers)

    def setMarkers(self, markers):
        r"""
        setMarkers(self, markers)
        Specify a new (possibly empty) collection of Markers for
        this AiffFile.
        """
        return _loris.AiffFile_setMarkers(self, markers)

# Register AiffFile in _loris:
_loris.AiffFile_swigregister(AiffFile)

class Analyzer(object):
    r"""
    An Analyzer represents a configuration of parameters for
    performing Reassigned Bandwidth-Enhanced Additive Analysis
    of sampled waveforms. This analysis process yields a collection 
    of Partials, each having a trio of synchronous, non-uniformly-
    sampled breakpoint envelopes representing the time-varying 
    frequency, amplitude, and noisiness of a single bandwidth-
    enhanced sinusoid. 

    For more information about Reassigned Bandwidth-Enhanced 
    Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
    Model, refer to the Loris website: 

    	http://www.cerlsoundgroup.org/Loris/

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, resolutionHz) -> Analyzer
        __init__(self, resolutionHz, windowWidthHz) -> Analyzer
        __init__(self, resolutionEnv, windowWidthHz) -> Analyzer
        __init__(self, another) -> Analyzer
        Construct and return a new Analyzer configured with the given	
        frequency resolution (minimum instantaneous frequency	
        difference between Partials) and analysis window main 
        lobe width (between zeros). All other Analyzer parameters 	
        are computed from the specified resolution and window
        width. If the window width is not specified, 
        then it is set to twice the resolution. If an envelope is
        provided for the frequency resolution, then it describes
        the time-varying analysis resolution in Hz. 

        An Analyzer configuration can also be copied from another
        instance.
        """
        _loris.Analyzer_swiginit(self, _loris.new_Analyzer(*args))
    __swig_destroy__ = _loris.delete_Analyzer

    def analyze(self, *args):
        r"""
        analyze(self, vec, srate) -> PartialList
        analyze(self, vec, srate, env) -> PartialList
        Analyze a vector of (mono) samples at the given sample rate 	  	
        (in Hz) and return the resulting Partials in a PartialList.
        If specified, use a frequency envelope as a fundamental reference for
        Partial formation.
        """
        return _loris.Analyzer_analyze(self, *args)

    def ampFloor(self):
        r"""
        ampFloor(self) -> double
        Return the amplitude floor (lowest detected spectral amplitude),              
        in (negative) dB, for this Analyzer.
        """
        return _loris.Analyzer_ampFloor(self)

    def cropTime(self):
        r"""
        cropTime(self) -> double
        Return the crop time (maximum temporal displacement of a time-
        frequency data point from the time-domain center of the analysis
        window, beyond which data points are considered "unreliable")
        for this Analyzer.
        """
        return _loris.Analyzer_cropTime(self)

    def freqDrift(self):
        r"""
        freqDrift(self) -> double
        Return the maximum allowable frequency difference between                     
        consecutive Breakpoints in a Partial envelope for this Analyzer.
        """
        return _loris.Analyzer_freqDrift(self)

    def freqFloor(self):
        r"""
        freqFloor(self) -> double
        Return the frequency floor (minimum instantaneous Partial                  
        frequency), in Hz, for this Analyzer.
        """
        return _loris.Analyzer_freqFloor(self)

    def freqResolution(self, time=0.0):
        r"""
        freqResolution(self, time=0.0) -> double
        Return the frequency resolution (minimum instantaneous frequency          
        difference between Partials) for this Analyzer at the specified
        time in seconds. If no time is specified, then the initial resolution
        (at 0 seconds) is returned.
        """
        return _loris.Analyzer_freqResolution(self, time)

    def hopTime(self):
        r"""
        hopTime(self) -> double
        Return the hop time (which corresponds approximately to the 
        average density of Partial envelope Breakpoint data) for this 
        Analyzer.
        """
        return _loris.Analyzer_hopTime(self)

    def sidelobeLevel(self):
        r"""
        sidelobeLevel(self) -> double
        Return the sidelobe attenutation level for the Kaiser analysis window in
        positive dB. Higher numbers (e.g. 90) give very good sidelobe 
        rejection but cause the window to be longer in time. Smaller 
        numbers raise the level of the sidelobes, increasing the likelihood
        of frequency-domain interference, but allow the window to be shorter
        in time.
        """
        return _loris.Analyzer_sidelobeLevel(self)

    def windowWidth(self):
        r"""
        windowWidth(self) -> double
        Return the frequency-domain main lobe width (measured between 
        zero-crossings) of the analysis window used by this Analyzer.
        """
        return _loris.Analyzer_windowWidth(self)

    def phaseCorrect(self):
        r"""
        phaseCorrect(self) -> bool
        Return true if the phases and frequencies of the constructed
         partials should be modified to be consistent at the end of the
         analysis, and false otherwise. (Default is true.)
        """
        return _loris.Analyzer_phaseCorrect(self)

    def setAmpFloor(self, x):
        r"""
        setAmpFloor(self, x)
        Set the amplitude floor (lowest detected spectral amplitude), in              
        (negative) dB, for this Analyzer.
        """
        return _loris.Analyzer_setAmpFloor(self, x)

    def setBwRegionWidth(self, x):
        r"""
        setBwRegionWidth(self, x)
        Deprecated, use storeResidueBandwidth instead.
        """
        return _loris.Analyzer_setBwRegionWidth(self, x)

    def setCropTime(self, x):
        r"""
        setCropTime(self, x)
        Set the crop time (maximum temporal displacement of a time-
        frequency data point from the time-domain center of the analysis
        window, beyond which data points are considered "unreliable")
        for this Analyzer.
        """
        return _loris.Analyzer_setCropTime(self, x)

    def setFreqDrift(self, x):
        r"""
        setFreqDrift(self, x)
        Set the maximum allowable frequency difference between                     
        consecutive Breakpoints in a Partial envelope for this Analyzer.
        """
        return _loris.Analyzer_setFreqDrift(self, x)

    def setFreqFloor(self, x):
        r"""
        setFreqFloor(self, x)
        Set the amplitude floor (minimum instantaneous Partial                  
        frequency), in Hz, for this Analyzer.
        """
        return _loris.Analyzer_setFreqFloor(self, x)

    def setFreqResolution(self, *args):
        r"""
        setFreqResolution(self, x)
        setFreqResolution(self, e)
        Set the frequency resolution (minimum instantaneous frequency          
        difference between Partials) for this Analyzer. (Does not cause     
        other parameters to be recomputed.)
        """
        return _loris.Analyzer_setFreqResolution(self, *args)

    def setHopTime(self, x):
        r"""
        setHopTime(self, x)
        Set the hop time (which corresponds approximately to the average
        density of Partial envelope Breakpoint data) for this Analyzer.
        """
        return _loris.Analyzer_setHopTime(self, x)

    def setSidelobeLevel(self, x):
        r"""
        setSidelobeLevel(self, x)
        Set the sidelobe attenutation level for the Kaiser analysis window in
        positive dB. Larger numbers (e.g. 90) give very good sidelobe 
        rejection but cause the window to be longer in time. Smaller 
        numbers raise the level of the sidelobes, increasing the likelihood
        of frequency-domain interference, but allow the window to be shorter
        in time.
        """
        return _loris.Analyzer_setSidelobeLevel(self, x)

    def setWindowWidth(self, x):
        r"""
        setWindowWidth(self, x)
        Set the frequency-domain main lobe width (measured between 
        zero-crossings) of the analysis window used by this Analyzer.
        """
        return _loris.Analyzer_setWindowWidth(self, x)

    def setPhaseCorrect(self, TF=True):
        r"""
        setPhaseCorrect(self, TF=True)
        Indicate whether the phases and frequencies of the constructed
         partials should be modified to be consistent at the end of the
         analysis. (Default is true.)
        """
        return _loris.Analyzer_setPhaseCorrect(self, TF)

    def storeResidueBandwidth(self, *args):
        r"""
        storeResidueBandwidth(self, regionWidth=Analyzer::Default_ResidueBandwidth_RegionWidth)
        Construct Partial bandwidth envelopes during analysis
        by associating residual energy in the spectrum (after
        peak extraction) with the selected spectral peaks that
        are used to construct Partials. 

        regionWidth is the width (in Hz) of the bandwidth 
        association regions used by this process, must be positive.
        If unspecified, a default value is used.
        """
        return _loris.Analyzer_storeResidueBandwidth(self, *args)

    def storeConvergenceBandwidth(self, *args):
        r"""
        storeConvergenceBandwidth(self, tolerance=0.01*Analyzer::Default_ConvergenceBandwidth_TolerancePct)
        Construct Partial bandwidth envelopes during analysis
        by storing the mixed derivative of short-time phase, 
        scaled and shifted so that a value of 0 corresponds
        to a pure sinusoid, and a value of 1 corresponds to a
        bandwidth-enhanced sinusoid with maximal energy spread
        (minimum sinusoidal convergence).

        tolerance is the amount of range over which the 
        mixed derivative indicator should be allowed to drift away 
        from a pure sinusoid before saturating. This range is mapped
        to bandwidth values on the range [0,1]. Must be positive and 
        not greater than 1. If unspecified, a default value is used.
        """
        return _loris.Analyzer_storeConvergenceBandwidth(self, *args)

    def storeNoBandwidth(self):
        r"""
        storeNoBandwidth(self)
        Disable bandwidth envelope construction. Bandwidth 
        will be zero for all Breakpoints in all Partials.
        """
        return _loris.Analyzer_storeNoBandwidth(self)

    def bandwidthIsResidue(self):
        r"""
        bandwidthIsResidue(self) -> bool
        Return true if this Analyzer is configured to compute
        bandwidth envelopes using the spectral residue after
        peaks have been identified, and false otherwise.
        """
        return _loris.Analyzer_bandwidthIsResidue(self)

    def bandwidthIsConvergence(self):
        r"""
        bandwidthIsConvergence(self) -> bool
        Return true if this Analyzer is configured to compute
        bandwidth envelopes using the mixed derivative convergence
        indicator, and false otherwise.
        """
        return _loris.Analyzer_bandwidthIsConvergence(self)

    def bwRegionWidth(self):
        r"""
        bwRegionWidth(self) -> double
        Return the width (in Hz) of the Bandwidth Association regions
        used by this Analyzer, only if the spectral residue method is
        used to compute bandwidth envelopes. Return zero if the mixed
        derivative method is used, or if no bandwidth is computed.
        """
        return _loris.Analyzer_bwRegionWidth(self)

    def bwConvergenceTolerance(self):
        r"""
        bwConvergenceTolerance(self) -> double
        Return the mixed derivative convergence tolerance
        only if the convergence indicator is used to compute
        bandwidth envelopes. Return zero if the spectral residue
        method is used or if no bandwidth is computed.
        """
        return _loris.Analyzer_bwConvergenceTolerance(self)

    def fundamentalEnv(self):
        r"""
        fundamentalEnv(self) -> LinearEnvelope
        Return the fundamental frequency estimate envelope constructed
        during the most recent analysis performed by this Analyzer.
        Will be empty unless buildFundamentalEnv was invoked to enable the
        construction of this envelope during analysis.
        """
        return _loris.Analyzer_fundamentalEnv(self)

    def ampEnv(self):
        r"""
        ampEnv(self) -> LinearEnvelope
        Return the overall amplitude estimate envelope constructed
        during the most recent analysis performed by this Analyzer.
        """
        return _loris.Analyzer_ampEnv(self)

    def buildAmpEnv(self, TF=True):
        r"""
        buildAmpEnv(self, TF=True)
        Legacy support, do not use. The amplitude and frequency envelopes
        are always estimated.
        """
        return _loris.Analyzer_buildAmpEnv(self, TF)

    def buildFundamentalEnv(self, *args):
        r"""
        buildFundamentalEnv(self, fmin, fmax, threshDb=-60, threshHz=8000)
        buildFundamentalEnv(self, TF=True)
        Configure the fundamental frequency estimator.

        fmin is the lower bound on the fundamental frequency estimate.
        fmax is the upper bound on the fundamental frequency estimate
        threshDb is the lower bound on the amplitude of a spectral peak
        that will constribute to the fundamental frequency estimate (very
        low amplitude peaks tend to have less reliable frequency estimates).
        Default is -60 dB.
        threshHz is the upper bound on the frequency of a spectral
        peak that will constribute to the fundamental frequency estimate.
        Default is 8 kHz.

        The fundamental frequency estimate can be accessed by
        fundamentalEnv() after the analysis is complete.

        """
        return _loris.Analyzer_buildFundamentalEnv(self, *args)

# Register Analyzer in _loris:
_loris.Analyzer_swigregister(Analyzer)

class SdifFile(object):
    r"""
    Class SdifFile represents reassigned bandwidth-enhanced Partial 
    data in a SDIF-format data file. Construction of an SdifFile 
    from a stream or filename automatically imports the Partial
    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_SdifFile

    def write(self, path):
        r"""
        write(self, path)
        Export the Partials represented by this SdifFile to
        the file having the specified filename or path.
        """
        return _loris.SdifFile_write(self, path)

    def write1TRC(self, path):
        r"""
        write1TRC(self, path)
        Export the envelope Partials represented by this SdifFile to
        the file having the specified filename or path in the 1TRC
        format, resampled, and without phase or bandwidth information.
        """
        return _loris.SdifFile_write1TRC(self, path)

    def __init__(self, *args):
        r"""
        __init__(self, filename) -> SdifFile
        __init__(self) -> SdifFile
        __init__(self, l) -> SdifFile
        Initialize an instance of SdifFile by importing Partial data from
        the file having the specified filename or path, 
        or initialize an instance of SdifFile storing the Partials in
        the specified PartialList. If no PartialList is specified,
        construct an empty SdifFile.
        """
        _loris.SdifFile_swiginit(self, _loris.new_SdifFile(*args))

    def partials(self):
        r"""
        partials(self) -> PartialList
        Return a copy of the Partials represented by this SdifFile.
        """
        return _loris.SdifFile_partials(self)

    def addPartials(self, l):
        r"""
        addPartials(self, l)
        Add all the Partials in a PartialList to this SdifFile.
        """
        return _loris.SdifFile_addPartials(self, l)

    def markers(self):
        r"""
        markers(self) -> MarkerVector
        Return the (possibly empty) collection of Markers for 
        this SdifFile.
        """
        return _loris.SdifFile_markers(self)

    def addMarkers(self, markers):
        r"""
        addMarkers(self, markers)
        Append a collection of Markers for to the existing
        set of Markers for this SdifFile.
        """
        return _loris.SdifFile_addMarkers(self, markers)

    def setMarkers(self, markers):
        r"""
        setMarkers(self, markers)
        Specify a new (possibly empty) collection of Markers for
        this SdifFile.
        """
        return _loris.SdifFile_setMarkers(self, markers)

# Register SdifFile in _loris:
_loris.SdifFile_swigregister(SdifFile)

class SpcFile(object):
    r"""
    Class SpcFile represents a collection of reassigned bandwidth-enhanced
    Partial data in a SPC-format envelope stream data file, used by the
    real-time bandwidth-enhanced additive synthesizer implemented on the
    Symbolic Sound Kyma Sound Design Workstation. Class SpcFile manages 
    file I/O and conversion between Partials and envelope parameter streams.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_SpcFile

    def sampleRate(self):
        r"""
        sampleRate(self) -> double
        Return the sample rate for this SpcFile in Hz.
        """
        return _loris.SpcFile_sampleRate(self)

    def midiNoteNumber(self):
        r"""midiNoteNumber(self) -> double"""
        return _loris.SpcFile_midiNoteNumber(self)

    def addPartial(self, *args):
        r"""
        addPartial(self, p)
        addPartial(self, p, label)
        Add the specified Partial to the enevelope parameter streams
        represented by this SpcFile. If a label is specified, use that
        label, instead of the Partial's label, for the Partial added to
        the SpcFile.

        A SpcFile can contain only one Partial having any given (non-zero) 
        label, so an added Partial will replace a Partial having the 
        same label, if such a Partial exists.

        This may throw an InvalidArgument exception if an attempt is made
        to add unlabeled Partials, or Partials labeled higher than the
        allowable maximum.   

        """
        return _loris.SpcFile_addPartial(self, *args)

    def setMidiNoteNumber(self, nn):
        r"""
        setMidiNoteNumber(self, nn)
        Set the fractional MIDI note number assigned to this SpcFile. 
        If the sound has no definable pitch, use note number 60.0 (the default).
        """
        return _loris.SpcFile_setMidiNoteNumber(self, nn)

    def setSampleRate(self, rate):
        r"""
        setSampleRate(self, rate)
        Set the sampling freqency in Hz for the spc data in this
        SpcFile. This is the rate at which Kyma must be running to ensure
        proper playback of bandwidth-enhanced Spc data.
        The default sample rate is 44100 Hz.
        """
        return _loris.SpcFile_setSampleRate(self, rate)

    def write(self, filename, enhanced=True, endApproachTime=0):
        r"""
        write(self, filename, enhanced=True, endApproachTime=0)
        Export the envelope parameter streams represented by this SpcFile to
        the file having the specified filename or path. Export phase-correct 
        bandwidth-enhanced envelope parameter streams if enhanced is true 
        (the default), or pure sinsoidal streams otherwise.

        A nonzero endApproachTime indicates that the Partials do not include a
        release or decay, but rather end in a static spectrum corresponding to the
        final Breakpoint values of the partials. The endApproachTime specifies how
        long before the end of the sound the amplitude, frequency, and bandwidth
        values are to be modified to make a gradual transition to the static spectrum.

        If the endApproachTime is not specified, it is assumed to be zero, 
        corresponding to Partials that decay or release normally.
        """
        return _loris.SpcFile_write(self, filename, enhanced, endApproachTime)

    def __init__(self, *args):
        r"""
        __init__(self, filename) -> SpcFile
        __init__(self, midiNoteNum=60) -> SpcFile
        __init__(self, l, midiNoteNum=60) -> SpcFile
        Construct and return a new SpcFile by importing envelope parameter 
        streams from the file having the specified filename or path, 
        or initialize an instance of SpcFile having the specified fractional
        MIDI note number. If a PartialList is specified, add those
        Partials to the file. Otherwise, the new SpcFile contains 
        no Partials (or envelope parameter streams).
        The default MIDI note number is 60 (middle C).
        """
        _loris.SpcFile_swiginit(self, _loris.new_SpcFile(*args))

    def partials(self):
        r"""
        partials(self) -> PartialList
        Return a copy of the Partials represented by this SdifFile.
        """
        return _loris.SpcFile_partials(self)

    def addPartials(self, l):
        r"""
        addPartials(self, l)
        Add all the Partials in a PartialList to this SpcFile.

        A SpcFile can contain only one Partial having any given (non-zero) 
        label, so an added Partial will replace a Partial having the 
        same label, if such a Partial exists.

        This may throw an InvalidArgument exception if an attempt is made
        to add unlabeled Partials, or Partials labeled higher than the
        allowable maximum.
        """
        return _loris.SpcFile_addPartials(self, l)

    def markers(self):
        r"""
        markers(self) -> MarkerVector
        Return the (possibly empty) collection of Markers for 
        this SpcFile.
        """
        return _loris.SpcFile_markers(self)

    def addMarkers(self, markers):
        r"""
        addMarkers(self, markers)
        Append a collection of Markers for to the existing
        set of Markers for this SpcFile.
        """
        return _loris.SpcFile_addMarkers(self, markers)

    def setMarkers(self, markers):
        r"""
        setMarkers(self, markers)
        Specify a new (possibly empty) collection of Markers for
        this SpcFile.
        """
        return _loris.SpcFile_setMarkers(self, markers)

# Register SpcFile in _loris:
_loris.SpcFile_swigregister(SpcFile)

class PartialListIterator(object):
    r"""
    An iterator over a PartialList. Access Partials
    in a PartialList by invoking next until atEnd 
    returns true.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_PartialListIterator

    def atEnd(self):
        r"""
        atEnd(self) -> bool
        Return true if there are no more Partials in the PartialList.
        """
        return _loris.PartialListIterator_atEnd(self)

    def next(self):
        r"""
        next(self) -> Partial
        Return the next Partial in the PartialList that has not yet
        been returned by this iterator.
        """
        return _loris.PartialListIterator_next(self)

# Register PartialListIterator in _loris:
_loris.PartialListIterator_swigregister(PartialListIterator)

class PartialIterator(object):
    r"""Proxy of C++ SwigPartialIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_PartialIterator

    def atEnd(self):
        r"""
        atEnd(self) -> bool
        Return true if there are no more Breakpoints in the Partial.
        """
        return _loris.PartialIterator_atEnd(self)

    def next(self):
        r"""
        next(self) -> BreakpointPosition
        Return the next Breakpoint in the Partial that has not yet
        been returned by this iterator.
        """
        return _loris.PartialIterator_next(self)

# Register PartialIterator in _loris:
_loris.PartialIterator_swigregister(PartialIterator)

class PartialList(object):
    r"""
    A PartialList represents a collection of Bandwidth-Enhanced 
    Partials, each having a trio of synchronous, non-uniformly-
    sampled breakpoint envelopes representing the time-varying 
    frequency, amplitude, and noisiness of a single bandwidth-
    enhanced sinusoid.

    For more information about Bandwidth-Enhanced Partials and the  
    Reassigned Bandwidth-Enhanced Additive Sound Model, refer to
    the Loris website: www.cerlsoundgroup.org/Loris/
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> PartialList
        __init__(self, rhs) -> PartialList
        Construct a new empty PartialList, or a PartialList
        that is a copy of another (containing identical copies
        of the Partials in another).
        """
        _loris.PartialList_swiginit(self, _loris.new_PartialList(*args))
    __swig_destroy__ = _loris.delete_PartialList

    def clear(self):
        r"""
        clear(self)
        Remove all the Partials from this PartialList.
        """
        return _loris.PartialList_clear(self)

    def size(self):
        r"""
        size(self) -> unsigned long
        Return the number of Partials in this PartialList.
        """
        return _loris.PartialList_size(self)

    def iterator(self):
        r"""
        iterator(self) -> PartialListIterator
        Return an iterator on the Partials in this PartialList.
        """
        return _loris.PartialList_iterator(self)

    def __iter__(self):
        r"""
        __iter__(self) -> PartialListIterator
        Return an iterator on the Partials in this PartialList.
        """
        return _loris.PartialList___iter__(self)

    def __len__(self):
        r"""
        __len__(self) -> unsigned long
        Return the number of Partials in this PartialList.
        """
        return _loris.PartialList___len__(self)

    def append(self, *args):
        r"""
        append(self, partial)
        append(self, other)
        Append a copy of a Partial, or copies of all the Partials in
        another PartialList, to this PartialList.
        """
        return _loris.PartialList_append(self, *args)

    def remove(self, partial):
        r"""
        remove(self, partial)
        Remove the specified Partial from this PartialList. An
        exception is raised if the specified Partial is not a member
        of this PartialList. The Partial itself must be a member, not
        merely identical to a Partial in this PartialList.
        """
        return _loris.PartialList_remove(self, partial)

    def first(self):
        r"""
        first(self) -> Partial
        Return the first Partial this PartialList, or 0 if this
        PartialList is empty.
        """
        return _loris.PartialList_first(self)

    def last(self):
        r"""
        last(self) -> Partial
        Return the last Partial this PartialList, or 0 if this
        PartialList is empty.
        """
        return _loris.PartialList_last(self)

    def copy(self):
        r"""
        copy(self) -> PartialList
        Construct a new a PartialList that is a copy of 
        another (containing identical copies of the Partials 
        in another). 

        This member is deprecated, use the normal copy constructor:
           plist_copy = PartialList( plist )

        """
        return _loris.PartialList_copy(self)

# Register PartialList in _loris:
_loris.PartialList_swigregister(PartialList)

class Partial(object):
    r"""
    A Partial represents a single component in the
    reassigned bandwidth-enhanced additive model. A Partial
    consists of a chain of Breakpoints describing the
    time-varying frequency, amplitude, and bandwidth (or
    noisiness) envelopes of the component, and a 4-byte
    label. The Breakpoints are non-uniformly distributed in
    time. For more information about Reassigned
    Bandwidth-Enhanced Analysis and the Reassigned
    Bandwidth-Enhanced Additive Sound Model, refer to the
    Loris website: 
        www.cerlsoundgroup.org/Loris/

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> Partial
        __init__(self, arg2) -> Partial
        Construct a new empty Partial, having no Breakpoints,
        or a Partial that is a copy of another (containing
        identical of the Breakpoints in another).
        """
        _loris.Partial_swiginit(self, _loris.new_Partial(*args))
    __swig_destroy__ = _loris.delete_Partial

    def label(self):
        r"""
        label(self) -> int
        Return the label (an integer) for this Partial. The
        default label is 0.
        """
        return _loris.Partial_label(self)

    def initialPhase(self):
        r"""
        initialPhase(self) -> double
        Return the starting phase (in radians) for this
        Partial. An exception is raised if there are no
        Breakpoints in this Partial.
        """
        return _loris.Partial_initialPhase(self)

    def startTime(self):
        r"""
        startTime(self) -> double
        Return the time (in seconds) of the first Breakpoint in
        this Partial. An exception is raised if there are no
        Breakpoints in this Partial.
        """
        return _loris.Partial_startTime(self)

    def endTime(self):
        r"""
        endTime(self) -> double
        Return the time (in seconds) of the last Breakpoint in
        this Partial. An exception is raised if there are no
        Breakpoints in this Partial.
        """
        return _loris.Partial_endTime(self)

    def duration(self):
        r"""
        duration(self) -> double
        Return the difference in time (in seconds) between the 
        first and last Breakpoints in this Partial.
        """
        return _loris.Partial_duration(self)

    def numBreakpoints(self):
        r"""
        numBreakpoints(self) -> long
        Return the number of Breakpoints in this Partial.
        """
        return _loris.Partial_numBreakpoints(self)

    def setLabel(self, l):
        r"""
        setLabel(self, l)
        Set the label (an integer) for this Partial. Unlabeled
        Partials have the default label of 0.
        """
        return _loris.Partial_setLabel(self, l)

    def frequencyAt(self, time):
        r"""
        frequencyAt(self, time) -> double
        Return the interpolated frequency (in Hz) of this
        Partial at the specified time in seconds. The frequency
        at times earlier than the first Breakpoint is the
        frequency of the first Breakpoint. The frequency at
        times later than the last Breakpoint is the frequency of
        the last Breakpoint. An exception is raised if there are
        no Breakpoints in this Partial.
        """
        return _loris.Partial_frequencyAt(self, time)

    def amplitudeAt(self, time):
        r"""
        amplitudeAt(self, time) -> double
        Return the interpolated amplitude of this Partial at
        the specified time in seconds. The amplitude at times
        earlier than the first Breakpoint and at times later
        than the last Breakpoint is zero. An exception is raised
        if there are no Breakpoints in this Partial.
        """
        return _loris.Partial_amplitudeAt(self, time)

    def bandwidthAt(self, time):
        r"""
        bandwidthAt(self, time) -> double
        Return the interpolated bandwidth (between 0 and 1) of
        this Partial at the specified time in seconds. The
        bandwidth at times earlier than the first Breakpoint and
        at times later than the last Breakpoint is zero. An
        exception is raised if there are no Breakpoints in this
        Partial.
        """
        return _loris.Partial_bandwidthAt(self, time)

    def phaseAt(self, time):
        r"""
        phaseAt(self, time) -> double
        Return the interpolated phase (in radians) of this
        Partial at the specified time in seconds. The phase at
        times earlier than the first Breakpoint is extrapolated
        from phase of the first Breakpoint assuming constant
        frequency. The phase at times later than the last
        Breakpoint is the extrapolated from the phase of the
        last Breakpoint assuming constant frequency. An
        exception is raised if there are no Breakpoints in this
        Partial.
        """
        return _loris.Partial_phaseAt(self, time)

    def iterator(self, *args):
        r"""
        iterator(self) -> PartialIterator
        iterator(self, startHere) -> PartialIterator
        Return an iterator on the BreakpointPositions in this
        Partial. Optionally, specify the initial BreakpointPosition
        for the new iterator.
        """
        return _loris.Partial_iterator(self, *args)

    def __iter__(self):
        r"""
        __iter__(self) -> PartialIterator
        Return an iterator on the BreakpointPositions in this 
        Partial.
        """
        return _loris.Partial___iter__(self)

    def remove(self, pos):
        r"""
        remove(self, pos)
        Remove the specified Breakpoint from this Partial. An
        exception is raised if the specified Breakpoint is not a
        member of this Partial. The Breakpoint itself must be a
        member, not merely identical to a Breakpoint in this
        Partial.
        """
        return _loris.Partial_remove(self, pos)

    def first(self):
        r"""
        first(self) -> Breakpoint
        Return the first Breakpoint this Partial, or 0 if this
        Partial is empty.
        """
        return _loris.Partial_first(self)

    def last(self):
        r"""
        last(self) -> Breakpoint
        Return the last Breakpoint this Partial, or 0 if this
        Partial is empty.
        """
        return _loris.Partial_last(self)

    def insert(self, time, bp):
        r"""
        insert(self, time, bp)
        Insert a copy of the Breakpoint bp into this Partial at
        the specified time in seconds. Return nothing.
        """
        return _loris.Partial_insert(self, time, bp)

    def findAfter(self, time):
        r"""
        findAfter(self, time) -> BreakpointPosition
        Return a BreakpointPosition positioned at
        the first Breakpoint in this Partial that is later than
        the specified time. The iterator might be at its end
        (return no more Breakpoints) if there are no Breakpoints
        in this Partial later than the specified time.
        """
        return _loris.Partial_findAfter(self, time)

    def findNearest(self, time):
        r"""
        findNearest(self, time) -> BreakpointPosition
        Return a BreakpointPosition positioned at
        the Breakpoint in this Partial that is nearest to the
        specified time.
        """
        return _loris.Partial_findNearest(self, time)

# Register Partial in _loris:
_loris.Partial_swigregister(Partial)

class Breakpoint(object):
    r"""
    A Breakpoint represents a single breakpoint in the
    time-varying frequency, amplitude, and bandwidth
    envelope of a Reassigned Bandwidth-Enhanced Partial.

    Instantaneous phase is also stored, but is only used at
    the onset of a partial, or when it makes a transition
    from zero to nonzero amplitude.

    A Partial represents a Reassigned Bandwidth-Enhanced
    model component. For more information about
    Bandwidth-Enhanced Partials and the Reassigned
    Bandwidth-Enhanced Additive Sound Model, refer to the
    Loris website:
        www.cerlsoundgroup.org/Loris/

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, f, a, b, p=0.) -> Breakpoint
        __init__(self, rhs) -> Breakpoint
        A Breakpoint represents a single breakpoint in the
        time-varying frequency, amplitude, and bandwidth
        envelope of a Reassigned Bandwidth-Enhanced Partial.

        Instantaneous phase is also stored, but is only used at
        the onset of a partial, or when it makes a transition
        from zero to nonzero amplitude.

        A Partial represents a Reassigned Bandwidth-Enhanced
        model component. For more information about
        Bandwidth-Enhanced Partials and the Reassigned
        Bandwidth-Enhanced Additive Sound Model, refer to the
        Loris website:
            www.cerlsoundgroup.org/Loris/

        """
        _loris.Breakpoint_swiginit(self, _loris.new_Breakpoint(*args))
    __swig_destroy__ = _loris.delete_Breakpoint

    def frequency(self):
        r"""
        frequency(self) -> double
        Return the frequency (in Hz) of this Breakpoint.
        """
        return _loris.Breakpoint_frequency(self)

    def amplitude(self):
        r"""
        amplitude(self) -> double
        Return the amplitude (absolute) of this Breakpoint.
        """
        return _loris.Breakpoint_amplitude(self)

    def bandwidth(self):
        r"""
        bandwidth(self) -> double
        Return the bandwidth, or noisiness (0 to 1) of 
        this Breakpoint.
        """
        return _loris.Breakpoint_bandwidth(self)

    def phase(self):
        r"""
        phase(self) -> double
        Return the phase (in radians) of this Breakpoint.
        """
        return _loris.Breakpoint_phase(self)

    def setFrequency(self, x):
        r"""
        setFrequency(self, x)
        Set the frequency (in Hz) of this Breakpoint.
        """
        return _loris.Breakpoint_setFrequency(self, x)

    def setAmplitude(self, x):
        r"""
        setAmplitude(self, x)
        Set the amplitude (absolute) of this Breakpoint.
        """
        return _loris.Breakpoint_setAmplitude(self, x)

    def setBandwidth(self, x):
        r"""
        setBandwidth(self, x)
        Set the bandwidth, or noisiness (0 to 1) of 
        this Breakpoint.
        """
        return _loris.Breakpoint_setBandwidth(self, x)

    def setPhase(self, x):
        r"""
        setPhase(self, x)
        Set the phase (in radians) of this Breakpoint.
        """
        return _loris.Breakpoint_setPhase(self, x)

# Register Breakpoint in _loris:
_loris.Breakpoint_swigregister(Breakpoint)

class BreakpointPosition(object):
    r"""
    A BreakpointPosition represents the position of a 
    Breakpoint within a Partial.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_BreakpointPosition

    def time(self):
        r"""
        time(self) -> double
        Return the time (in seconds) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_time(self)

    def breakpoint(self):
        r"""
        breakpoint(self) -> Breakpoint
        Return the Breakpoint (not a copy!) at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_breakpoint(self)

    def frequency(self):
        r"""
        frequency(self) -> double
        Return the frequency (in Hz) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_frequency(self)

    def amplitude(self):
        r"""
        amplitude(self) -> double
        Return the amplitude (absolute) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_amplitude(self)

    def bandwidth(self):
        r"""
        bandwidth(self) -> double
        Return the bandwidth, or noisiness (0 to 1) of the
        Breakpoint at this BreakpointPosition.
        """
        return _loris.BreakpointPosition_bandwidth(self)

    def phase(self):
        r"""
        phase(self) -> double
        Return the phase (in radians) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_phase(self)

    def setFrequency(self, x):
        r"""
        setFrequency(self, x)
        Set the frequency (in Hz) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_setFrequency(self, x)

    def setAmplitude(self, x):
        r"""
        setAmplitude(self, x)
        Set the amplitude (absolute) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_setAmplitude(self, x)

    def setBandwidth(self, x):
        r"""
        setBandwidth(self, x)
        Set the bandwidth, or noisiness (0 to 1) of the
        Breakpoint at this BreakpointPosition.
        """
        return _loris.BreakpointPosition_setBandwidth(self, x)

    def setPhase(self, x):
        r"""
        setPhase(self, x)
        Set the phase (in radians) of the Breakpoint at this
        BreakpointPosition.
        """
        return _loris.BreakpointPosition_setPhase(self, x)

# Register BreakpointPosition in _loris:
_loris.BreakpointPosition_swigregister(BreakpointPosition)

class F0Estimate(object):
    r"""
    Represents a configuration of an iterative alrogithm for computing an 
    estimate of fundamental frequency from a sequence of sinusoidal
    frequencies and amplitudes using a likelihood estimator adapted
    from Quatieri's Speech Signal Processing text.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, amps, freqs, fmin, fmax, resolution):
        r"""
        __init__(self, amps, freqs, fmin, fmax, resolution) -> F0Estimate
        Construct from parameters of the iterative F0 estimation 
        algorithm. Find candidate F0 estimates as integer divisors
        of the peak frequencies, pick the highest frequency of the
        most likely candidates, and refine that estiamte using the
        secant method. 

        Store the frequency and the normalized value of the 
        likelihood function at that frequency (1.0 indicates that
        all the peaks are perfect harmonics of the estimated
        frequency).
        """
        _loris.F0Estimate_swiginit(self, _loris.new_F0Estimate(amps, freqs, fmin, fmax, resolution))

    def frequency(self):
        r"""
        frequency(self) -> double
        Return the F0 frequency estimate, in Hz, for this estimate.
        """
        return _loris.F0Estimate_frequency(self)

    def confidence(self):
        r"""
        confidence(self) -> double
        Return the normalized confidence for this estimate, 
        equal to 1.0 when all frequencies are perfect
        harmonics of this estimate's frequency.
        """
        return _loris.F0Estimate_confidence(self)
    __swig_destroy__ = _loris.delete_F0Estimate

# Register F0Estimate in _loris:
_loris.F0Estimate_swigregister(F0Estimate)

class FundamentalEstimator(object):
    r"""
    Base class for fundamental estimation, common storage for member
    variable parameters, type definitions, and constants.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DefaultAmpFloor = _loris.FundamentalEstimator_DefaultAmpFloor
    
    DefaultAmpRange = _loris.FundamentalEstimator_DefaultAmpRange
    
    DefaultFreqCeiling = _loris.FundamentalEstimator_DefaultFreqCeiling
    
    DefaultPrecisionOver100 = _loris.FundamentalEstimator_DefaultPrecisionOver100
    
    DefaultMinConfidencePct = _loris.FundamentalEstimator_DefaultMinConfidencePct
    

    def ampFloor(self):
        r"""
        ampFloor(self) -> double
        Return the absolute amplitude threshold in (negative) dB, 
        below which spectral peaks will not be considered in the 
        estimation of the fundamental (default is 30 dB).
        """
        return _loris.FundamentalEstimator_ampFloor(self)

    def ampRange(self):
        r"""
        ampRange(self) -> double
        Return the amplitude range in dB, 
        relative to strongest peak in a frame, floating
        amplitude threshold (negative) below which spectral
        peaks will not be considered in the estimation of 
        the fundamental (default is 30 dB).	
        """
        return _loris.FundamentalEstimator_ampRange(self)

    def freqCeiling(self):
        r"""
        freqCeiling(self) -> double
        Return the frequency ceiling in Hz, the
        frequency threshold above which spectral
        peaks will not be considered in the estimation of 
        the fundamental (default is 10 kHz).  
        """
        return _loris.FundamentalEstimator_freqCeiling(self)

    def precision(self):
        r"""
        precision(self) -> double
        Return the precision of the estimate in Hz, the
        fundamental frequency will be estimated to 
        within this range (default is 0.1 Hz).
        """
        return _loris.FundamentalEstimator_precision(self)

    def setAmpFloor(self, x):
        r"""
        setAmpFloor(self, x)
        Set the absolute amplitude threshold in (negative) dB, 
        below which spectral peaks will not be considered i
        """
        return _loris.FundamentalEstimator_setAmpFloor(self, x)

    def setAmpRange(self, x):
        r"""
        setAmpRange(self, x)
        Set the amplitude range in dB, 
        relative to strongest peak in a frame, floating
        amplitude threshold (negative) below which spectral
        peaks will not be considered in the estimation of 
        the fundamental (default is 30 dB).	
        """
        return _loris.FundamentalEstimator_setAmpRange(self, x)

    def setFreqCeiling(self, x):
        r"""
        setFreqCeiling(self, x)
        Set the frequency ceiling in Hz, the
        frequency threshold above which spectral
        peaks will not be considered in the estimation of 
        the fundamental (default is 10 kHz). Must be
        greater than the lower bound.
        """
        return _loris.FundamentalEstimator_setFreqCeiling(self, x)

    def setPrecision(self, x):
        r"""
        setPrecision(self, x)
        Set the precision of the estimate in Hz, the
        fundamental frequency will be estimated to 
        within this range (default is 0.1 Hz)
        """
        return _loris.FundamentalEstimator_setPrecision(self, x)
    __swig_destroy__ = _loris.delete_FundamentalEstimator

# Register FundamentalEstimator in _loris:
_loris.FundamentalEstimator_swigregister(FundamentalEstimator)

class FundamentalFromPartials(FundamentalEstimator):
    r"""
    Class FundamentalFromPartials represents an algorithm for 
    time-varying fundamental frequency estimation from instantaneous
    Partial amplitudes and frequencies based on a likelihood
    estimator adapted from Quatieri's Speech Signal Processing text.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, precisionHz=FundamentalEstimator::DefaultPrecisionOver100*0.01) -> FundamentalFromPartials
        Construct a new estimator.

        The specified precision is used to terminate the iterative
        estimation procedure. If unspecified, the default value,
        DefaultPrecisionOver100 * 100 is used. 

        precisionHz is the precision in Hz with which the 
        fundamental estimates will be made.
        """
        _loris.FundamentalFromPartials_swiginit(self, _loris.new_FundamentalFromPartials(*args))

    def buildEnvelope(self, partials, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold):
        r"""
        buildEnvelope(self, partials, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold) -> LinearEnvelope
        Construct a linear envelope from fundamental frequency 
        estimates taken at the specified interval in seconds 
        starting at tbeg (seconds) and ending before tend (seconds).

        	partials is the sequence of Partials

        	tbeg is the beginning of the time interval (in seconds)

        	tend is the end of the time interval (in seconds)

        	interval is the time between breakpoints in the
        	fundamental frequency envelope (in seconds)

        	lowerFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	upperFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	confidenceThreshold is the minimum confidence level
        	resuired for a fundamental frequency estimate to be
        	added to the envelope. Lower confidence estimates are
        	not added, the envelope returned will not contain
        	breakpoints at times associated with low confidence 
        	estimates

        	Returns a LinearEnvelope composed of breakpoints corresponding to
        	the fundamental frequency estimates at samples of the span
        	tbeg to tend at the specified sampling interval, only estimates
        	having confidence level exceeding the specified confidence
        	threshold are added to the envelope

        """
        return _loris.FundamentalFromPartials_buildEnvelope(self, partials, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold)

    def estimateAt(self, partials, time, lowerFreqBound, upperFreqBound):
        r"""
        estimateAt(self, partials, time, lowerFreqBound, upperFreqBound) -> F0Estimate
        Return an estimate of the fundamental frequency computed 
        at the specified time. The F0Estimate returned stores the
        estimate of the fundamental frequency (in Hz) and the 
        relative confidence (from 0 to 1) associated with that
        estimate.

        	partials is the sequence of Partials

        	time is the time in seconds at which to attempt to estimate
        	the fundamental frequency

        	lowerFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	upperFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	Return the estimate of fundamental frequency in Hz and the 
        	confidence associated with that estimate (see 
        	F0Estimate.h)

        """
        return _loris.FundamentalFromPartials_estimateAt(self, partials, time, lowerFreqBound, upperFreqBound)
    __swig_destroy__ = _loris.delete_FundamentalFromPartials

# Register FundamentalFromPartials in _loris:
_loris.FundamentalFromPartials_swigregister(FundamentalFromPartials)

class FundamentalFromSamples(FundamentalEstimator):
    r"""
    Class FundamentalFromSamples represents an algorithm for 
    time-varying fundamental frequency estimation based on
    time-frequency reassigned spectral analysis of a sequence
    of samples. This class is adapted from the Analyzer class 
    (see Analyzer.h), and performs the same spectral analysis 
    and peak extraction, but does not form Partials.

    For more information about Reassigned Bandwidth-Enhanced 
    Analysis and the Reassigned Bandwidth-Enhanced Additive Sound 
    Model, refer to the Loris website: www.cerlsoundgroup.org/Loris/.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, winWidthHz, precisionHz=FundamentalEstimator::DefaultPrecisionOver100*0.01) -> FundamentalFromSamples
        Construct a new estimator configured with the given  
        analysis window width (main lobe, zero-to-zero). All other 
        spectrum analysis parameters are computed from the specified 
        window width. 

        The specified precision is used to terminate the iterative
        estimation procedure. If unspecified, the default value,
        DefaultPrecisionOver100 * 100 is used. 

        	windowWidthHz is the main lobe width of the Kaiser
        	analysis window in Hz.

        	precisionHz is the precision in Hz with which the 
        	fundamental estimates will be made.

        """
        _loris.FundamentalFromSamples_swiginit(self, _loris.new_FundamentalFromSamples(*args))

    def buildEnvelope(self, samps, sampleRate, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold):
        r"""
        buildEnvelope(self, samps, sampleRate, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold) -> LinearEnvelope
        Construct a linear envelope from fundamental frequency 
        estimates taken at the specified interval in seconds
        starting at tbeg (seconds) and ending before tend (seconds).

        	samps is the sequence of samples

        	sampleRate is the sampling rate (in Hz) associated
        	with the sequence of samples (used to compute frequencies
        	in Hz, and to convert the time from seconds to samples)

        	tbeg is the beginning of the time interval (in seconds)

        	tend is the end of the time interval (in seconds)

        	interval is the time between breakpoints in the
        	fundamental frequency envelope (in seconds)

        	lowerFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	upperFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	confidenceThreshold is the minimum confidence level
        	resuired for a fundamental frequency estimate to be
        	added to the envelope. Lower confidence estimates are
        	not added, the envelope returned will not contain
        	breakpoints at times associated with low confidence 
        	estimates

        	Returns a LinearEnvelope composed of breakpoints corresponding to
        	the fundamental frequency estimates at samples of the span
        	tbeg to tend at the specified sampling interval, only estimates
        	having confidence level exceeding the specified confidence
        	threshold are added to the envelope    

        """
        return _loris.FundamentalFromSamples_buildEnvelope(self, samps, sampleRate, tbeg, tend, interval, lowerFreqBound, upperFreqBound, confidenceThreshold)

    def estimateAt(self, samps, sampleRate, time, lowerFreqBound, upperFreqBound):
        r"""
        estimateAt(self, samps, sampleRate, time, lowerFreqBound, upperFreqBound) -> F0Estimate
        Return an estimate of the fundamental frequency computed 
        at the specified time. The F0Estimate returned stores the
        estimate of the fundamental frequency (in Hz) and the 
        relative confidence (from 0 to 1) associated with that
        estimate.

        	samps is the sequence of samples

        	sampleRate is the sampling rate (in Hz) associated
        	with the sequence of samples (used to compute frequencies
        	in Hz, and to convert the time from seconds to samples)

        	time is the time in seconds at which to attempt to estimate
        	the fundamental frequency

        	lowerFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	upperFreqBound is the lower bound on the fundamental
        	frequency estimate (in Hz)

        	Returns the estimate of fundamental frequency in Hz and the 
        	confidence associated with that estimate (see 
        	F0Estimate.h)

        """
        return _loris.FundamentalFromSamples_estimateAt(self, samps, sampleRate, time, lowerFreqBound, upperFreqBound)

    def windowWidth(self):
        r"""
        windowWidth(self) -> double
        Return the frequency-domain main lobe width (in Hz measured 
        between zero-crossings) of the analysis window used in spectral
        analysis.
        """
        return _loris.FundamentalFromSamples_windowWidth(self)

    def setWindowWidth(self, w):
        r"""
        setWindowWidth(self, w)
        Set the frequency-domain main lobe width (in Hz measured 
        between zero-crossings) of the analysis window used in spectral
        analysis.
        """
        return _loris.FundamentalFromSamples_setWindowWidth(self, w)
    __swig_destroy__ = _loris.delete_FundamentalFromSamples

# Register FundamentalFromSamples in _loris:
_loris.FundamentalFromSamples_swigregister(FundamentalFromSamples)

class Envelope(object):
    r"""
    Envelope is an abstract base class for all time-varying envelopes
    and parameters, representing a single-valued funtion of one variable
    (usually time).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Envelope(self, other):
        r"""
        Envelope(self, other) -> Envelope
        Envelope is an abstract base class for all time-varying envelopes
        and parameters, representing a single-valued funtion of one variable
        (usually time).
        """
        return _loris.Envelope_Envelope(self, other)
    __swig_destroy__ = _loris.delete_Envelope

# Register Envelope in _loris:
_loris.Envelope_swigregister(Envelope)

class LinearEnvelope(Envelope):
    r"""
    A LinearEnvelope represents a linear segment breakpoint 
    function with infinite extension at each end (that is, the 
    values past either end of the breakpoint function have the 
    values at the nearest end).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> LinearEnvelope
        __init__(self, arg2) -> LinearEnvelope
        __init__(self, initialValue) -> LinearEnvelope
        Construct and return a new LinearEnvelope, empty,
        or having a single breakpoint at time 0 with the 
        specified value.

        An LinearEnvelope can also be copied from another
        instance.
        """
        _loris.LinearEnvelope_swiginit(self, _loris.new_LinearEnvelope(*args))
    __swig_destroy__ = _loris.delete_LinearEnvelope

    def insertBreakpoint(self, time, value):
        r"""
        insertBreakpoint(self, time, value)
        Insert a new breakpoint into the envelope at the specified
        time and value.
        """
        return _loris.LinearEnvelope_insertBreakpoint(self, time, value)

    def insert(self, time, value):
        r"""
        insert(self, time, value)
        Insert a new breakpoint into the envelope at the specified
        time and value.
        """
        return _loris.LinearEnvelope_insert(self, time, value)

    def valueAt(self, x):
        r"""
        valueAt(self, x) -> double
        Return the (linearly-interpolated) value of the envelope
        at the specified time.
        """
        return _loris.LinearEnvelope_valueAt(self, x)

    def size(self):
        r"""
        size(self) -> unsigned int
        Return the number of breakpoints in this LinearEnvelope.
        """
        return _loris.LinearEnvelope_size(self)

    def __iadd__(self, offset):
        r"""
        __iadd__(self, offset) -> LinearEnvelope
        Add a constant value to this LinearEnvelope and return a reference
        to self.
        """
        return _loris.LinearEnvelope___iadd__(self, offset)

    def __isub__(self, offset):
        r"""
        __isub__(self, offset) -> LinearEnvelope
        Subtract a constant value from this LinearEnvelope and return a reference
        to self.
        """
        return _loris.LinearEnvelope___isub__(self, offset)

    def __imul__(self, scale):
        r"""
        __imul__(self, scale) -> LinearEnvelope
        Scale this LinearEnvelope by a constant value and return a reference
        to self.
        """
        return _loris.LinearEnvelope___imul__(self, scale)

    def __itruediv__(self, *args):
        return _loris.LinearEnvelope___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __add__(self, *args):
        r"""
        __add__(self, offset) -> LinearEnvelope
        __add__(self, rhs) -> LinearEnvelope
        Add a constant value or a LinearEnvelope to this LinearEnvelope 
        and return a new LinearEnvelope.
        """
        return _loris.LinearEnvelope___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, offset) -> LinearEnvelope
        __sub__(self, rhs) -> LinearEnvelope
        """
        return _loris.LinearEnvelope___sub__(self, *args)

    def __mul__(self, scale):
        r"""
        __mul__(self, scale) -> LinearEnvelope
        Scale a LinearEnvelope by a constant value and return a new 
        LinearEnvelope.
        """
        return _loris.LinearEnvelope___mul__(self, scale)

    def __truediv__(self, *args):
        return _loris.LinearEnvelope___truediv__(self, *args)
    __div__ = __truediv__



    def iterator(self, *args):
        r"""
        iterator(self) -> LinearEnvelopeIterator
        iterator(self, startHere) -> LinearEnvelopeIterator
        Return an iterator on the positions in this
        LinearEnvelope. Optionally, specify the initial position
        for the new iterator.
        """
        return _loris.LinearEnvelope_iterator(self, *args)

    def __iter__(self):
        r"""
        __iter__(self) -> LinearEnvelopeIterator
        Return an iterator on the positions in this 
        LinearEnvelope.
        """
        return _loris.LinearEnvelope___iter__(self)

# Register LinearEnvelope in _loris:
_loris.LinearEnvelope_swigregister(LinearEnvelope)

class LinearEnvelopePosition(object):
    r"""
    A LinearEnvelopePosition represents a breakpoint, a value
    associated with a particular time in a LinearEnvelope.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_LinearEnvelopePosition

    def time(self):
        r"""
        time(self) -> double
        Return the time (in seconds) of the corresponding to this
        LinearEnvelopePosition.
        """
        return _loris.LinearEnvelopePosition_time(self)

    def value(self):
        r"""
        value(self) -> double
        Return the value (arbitrary units) associated with this
        LinearEnvelopePosition.
        """
        return _loris.LinearEnvelopePosition_value(self)

    def setValue(self, x):
        r"""
        setValue(self, x)
        Assign the value (arbitrary units) associated with this
        LinearEnvelopePosition.
        """
        return _loris.LinearEnvelopePosition_setValue(self, x)

# Register LinearEnvelopePosition in _loris:
_loris.LinearEnvelopePosition_swigregister(LinearEnvelopePosition)

class LinearEnvelopeIterator(object):
    r"""
    An iterator over a LinearEnvelope. Access time-value pairs
    in a LinearEnvelope by invoking next until atEnd 
    returns true.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _loris.delete_LinearEnvelopeIterator

    def atEnd(self):
        r"""
        atEnd(self) -> bool
        Return true if there are no more time-value pairs in the LinearEnvelope.
        """
        return _loris.LinearEnvelopeIterator_atEnd(self)

    def next(self):
        r"""
        next(self) -> LinearEnvelopePosition
        Return the next time-value pair in the LinearEnvelope that has not yet
        been returned by this iterator.
        """
        return _loris.LinearEnvelopeIterator_next(self)

# Register LinearEnvelopeIterator in _loris:
_loris.LinearEnvelopeIterator_swigregister(LinearEnvelopeIterator)


def BreakpointEnvelope(*args):
    r"""
    BreakpointEnvelope() -> LinearEnvelope
    BreakpointEnvelope(rhs) -> LinearEnvelope
    BreakpointEnvelope(initialValue) -> LinearEnvelope
    BreakpointEnvelope is deprecated, use LinearEnvelope instead.
    """
    return _loris.BreakpointEnvelope(*args)

def BreakpointEnvelopeWithValue(initialValue):
    r"""
    BreakpointEnvelopeWithValue(initialValue) -> LinearEnvelope
    BreakpointEnvelopeWithValue is deprecated, use LinearEnvelope instead.
    """
    return _loris.BreakpointEnvelopeWithValue(initialValue)
class SynthesisParameters(object):
    r"""
    Access to Loris bandwidth-enhanced sinusoidal synthesis parameters. 
    Parameters assigned here are the default parameters used in Loris 
    synthesis. Some functions allow these parameters to be overridden
    (see e.g. loris.synthesize).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def fadeTime():
        r"""
        fadeTime() -> double
        Return the Loris Synthesizer's Partial fade time, in seconds.
        """
        return _loris.SynthesisParameters_fadeTime()

    @staticmethod
    def setFadeTime(t):
        r"""
        setFadeTime(t)
        Set the Loris Synthesizer's fade time to the specified value 
        (in seconds, must be non-negative).

        	t is the new Partial fade time in seconds.

        """
        return _loris.SynthesisParameters_setFadeTime(t)

    @staticmethod
    def sampleRate():
        r"""
        sampleRate() -> double
        Return the sampling rate (in Hz) for the Loris Synthesizer.
        """
        return _loris.SynthesisParameters_sampleRate()

    @staticmethod
    def setSampleRate(rate):
        r"""
        setSampleRate(rate)
        Set the Loris Synthesizer's sample rate to the specified value 
        (in Hz, must be positive).

        	rate is the new synthesis sample rate.

        """
        return _loris.SynthesisParameters_setSampleRate(rate)

    @staticmethod
    def filterCoefsNumerator():
        r"""
        filterCoefsNumerator() -> DoubleVector
        Return the numerator coefficients in the filter used by the Loris 
        Synthesizer in bandwidth-enhanced sinusoidal synthesis.
        """
        return _loris.SynthesisParameters_filterCoefsNumerator()

    @staticmethod
    def filterCoefsDenominator():
        r"""
        filterCoefsDenominator() -> DoubleVector
        Return the denominator coefficients in the filter used by the Loris 
        Synthesizer in bandwidth-enhanced sinusoidal synthesis.
        """
        return _loris.SynthesisParameters_filterCoefsDenominator()

    @staticmethod
    def setFilterCoefs(num, den):
        r"""
        setFilterCoefs(num, den)
        Set the coefficients in the filter used by the Loris 
        Synthesizer in bandwidth-enhanced sinusoidal synthesis.

            num is the new numerator coefficients
            den is the new denominator coefficients

        The zeroeth denominator coefficient must be non-zero. If it is not
        equal to 1.0, all the other coefficients are scaled by its inverse.

        """
        return _loris.SynthesisParameters_setFilterCoefs(num, den)

# Register SynthesisParameters in _loris:
_loris.SynthesisParameters_swigregister(SynthesisParameters)


def synthesize(*args):
    r"""
    synthesize(partials, srate) -> DoubleVector
    synthesize(partials) -> DoubleVector
    Synthesize Partials in a PartialList at the given sample rate, and
    return the (floating point) samples in a vector. The vector is
    sized to hold as many samples as are needed for the complete
    synthesis of all the Partials in the PartialList. 

    If the sample rate is unspecified, the sample rate in the default 
    SynthesisParameters is used. (See loris.SynthesisParameters.)
    """
    return _loris.synthesize(*args)
class Channelizer(object):
    r"""
    Class Channelizer represents an algorithm for automatic labeling of
    a sequence of Partials. Partials must be labeled in
    preparation for morphing (see Morpher) to establish correspondences
    between Partials in the morph source and target sounds. 

    Channelized partials are labeled according to their adherence to a
    harmonic frequency structure with a time-varying fundamental
    frequency. The frequency spectrum is partitioned into
    non-overlapping channels having time-varying center frequencies that
    are harmonic (integer) multiples of a specified reference frequency
    envelope, and each channel is identified by a unique label equal to
    its harmonic number. Each Partial is assigned the label
    corresponding to the channel containing the greatest portion of its
    (the Partial's) energy. 

    A reference frequency Envelope for channelization and the channel
    number to which it corresponds (1 for an Envelope that tracks the
    Partial at the fundamental frequency) must be specified. The
    reference Envelope can be constructed explcitly, point by point
    (using, for example, the BreakpointEnvelope class), or constructed
    automatically using the FrequencyReference class. 

    The Channelizer can be configured with a stretch factor, to accomodate
    detuned harmonics, as in the case of piano tones. The static member
    computeStretchFactor can compute the apppropriate stretch factor, given
    a pair of partials. This computation is based on formulae given in 
    'Understanding the complex nature of the piano tone' by Martin Keane
    at the Acoustics Research Centre at the University of Aukland (Feb 2004).
    The stretching factor must be non-negative (and is zero for perfectly
    tunes harmonics). Even in the case of stretched harmonics, the
    reference frequency envelope is assumed to track the frequency of
    one of the partials, and the center frequency of the corresponding
    channel, even though it may represent a stretched harmonic.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, refChanFreq, refChanLabel, stretchFactor=0) -> Channelizer
        __init__(self, refFreq, stretchFactor=0) -> Channelizer

        Construct a new Channelizer having a constant reference frequency.
        The specified frequency is the center frequency of the lowest-frequency
        channel (for a harmonic sound, the channel containing the fundamental 
        Partial.

            refFreq is the reference frequency (in Hz) corresponding
            to the first frequency channel.

            stretchFactor is a stretching factor to account for detuned 
            harmonics, default is 0. 

        """
        _loris.Channelizer_swiginit(self, _loris.new_Channelizer(*args))
    __swig_destroy__ = _loris.delete_Channelizer

    def channelize(self, *args):
        r"""
        channelize(self, partial)
        channelize(self, partials)
        Assign each Partial in the specified half-open (STL-style) range
        the label corresponding to the frequency channel containing the
        greatest portion of its (the Partial's) energy.

            partials is the list of Partials to channelize

        """
        return _loris.Channelizer_channelize(self, *args)

    def channelFrequencyAt(self, time, channel):
        r"""
        channelFrequencyAt(self, time, channel) -> double
        Compute the center frequency of one a channel at the specified
        time. For non-stretched harmonics, this is simply the value
        of the reference envelope scaled by the ratio of the specified
        channel number to the reference channel number. For stretched
        harmonics, the channel center frequency is computed using the
        stretch factor. See Martin Keane, 'Understanding
        the complex nature of the piano tone', 2004, for a discussion
        and the source of the mode frequency stretching algorithms 
        implemented here.

            time is the time (in seconds) at which to evalute 
            the reference envelope

            channel is the frequency channel (or harmonic, or vibrational     
            mode) number whose frequency is to be determined

            Returns the center frequency in Hz of the specified frequency channel
            at the specified time

        """
        return _loris.Channelizer_channelFrequencyAt(self, time, channel)

    def computeChannelNumber(self, time, frequency):
        r"""
        computeChannelNumber(self, time, frequency) -> int

        Compute the (fractional) channel number estimate for a Partial having a
        given frequency at a specified time. For ordinary harmonics, this
        is simply the ratio of the specified frequency to the reference
        frequency at the specified time. For stretched harmonics (as in 
        a piano), the stretching factor is used to compute the frequency
        of the corresponding modes of a massy string. See Martin Keane, 
        'Understanding the complex nature of the piano tone', 2004, for 
        the source of the mode frequency stretching algorithms 
        implemented here.

            time is the time (in seconds) at which to evalute 
            the reference envelope

            frequency is the frequency (in Hz) for wihch the channel
            number is to be determined

            returns the channel number corresponding to the specified
            frequency and time

        """
        return _loris.Channelizer_computeChannelNumber(self, time, frequency)

    def computeFractionalChannelNumber(self, time, frequency):
        r"""
        computeFractionalChannelNumber(self, time, frequency) -> double
        Compute the (fractional) channel number estimate for a Partial having a
        given frequency at a specified time. For ordinary harmonics, this
        is simply the ratio of the specified frequency to the reference
        frequency at the specified time. For stretched harmonics (as in 
        a piano), the stretching factor is used to compute the frequency
        of the corresponding modes of a massy string. See Martin Keane, 
        'Understanding the complex nature of the piano tone', 2004, for 
        the source of the mode frequency stretching algorithms 
        implemented here.

        The fractional channel number is used internally to determine
        a best estimate for the channel number (label) for a Partial
        having time-varying frequency. 

            time is the time (in seconds) at which to evalute 
            the reference envelope

            frequency is the frequency (in Hz) for wihch the channel
            number is to be determined

            returns the fractional channel number corresponding to the specified
            frequency and time

        """
        return _loris.Channelizer_computeFractionalChannelNumber(self, time, frequency)

    def referenceFrequencyAt(self, time):
        r"""
        referenceFrequencyAt(self, time) -> double
        Compute the reference frequency at the specified time. For non-stretched 
        harmonics, this is simply the ratio of the reference envelope evaluated 
        at that time to the reference channel number, and is the center frequecy
        for the lowest channel. For stretched harmonics, the reference frequency 
        is NOT equal to the center frequency of any of the channels, and is also
        a function of the stretch factor. 

            time is the time (in seconds) at which to evalute 
            the reference envelope

        """
        return _loris.Channelizer_referenceFrequencyAt(self, time)

    def amplitudeWeighting(self):
        r"""
        amplitudeWeighting(self) -> double
        Return the exponent applied to amplitude before weighting
        the instantaneous estimate of the frequency channel number
        for a Partial. zero (default) for no weighting, 1 for linear
        amplitude weighting, 2 for power weighting, etc.
        Amplitude weighting is a bad idea for many sounds, particularly
        those with transients, for which it may emphasize the part of
        the Partial having the least reliable frequency estimate.

        """
        return _loris.Channelizer_amplitudeWeighting(self)

    def setAmplitudeWeighting(self, expon):
        r"""
        setAmplitudeWeighting(self, expon)
        Set the exponent applied to amplitude before weighting
        the instantaneous estimate of the frequency channel number
        for a Partial. zero (default) for no weighting, 1 for linear
        amplitude weighting, 2 for power weighting, etc.
        Amplitude weighting is a bad idea for many sounds, particularly
        those with transients, for which it may emphasize the part of
        the Partial having the least reliable frequency estimate.

        """
        return _loris.Channelizer_setAmplitudeWeighting(self, expon)

    def stretchFactor(self):
        r"""
        stretchFactor(self) -> double
        Return the stretching factor used to account for detuned
        harmonics, as in a piano tone. Normally set to 0 for 
        in-tune harmonics.

        The stretching factor is a small positive number for 
        heavy vibrating strings (as in pianos) for which the
        mass of the string significantly affects the frequency
        of the vibrating modes. See Martin Keane, 'Understanding
        the complex nature of the piano tone', 2004, for a discussion
        and the source of the mode frequency stretching algorithms 
        implemented here.

        """
        return _loris.Channelizer_stretchFactor(self)

    def setStretchFactor(self, stretch):
        r"""
        setStretchFactor(self, stretch)
        Set the stretching factor used to account for detuned
        harmonics, as in a piano tone. Normally set to 0 for 
        in-tune harmonics. The stretching factor for massy 
        vibrating strings (like pianos) can be computed from 
        the physical characteristics of the string, or using 
        computeStretchFactor(). 

        The stretching factor is a small positive number for 
        heavy vibrating strings (as in pianos) for which the
        mass of the string significantly affects the frequency
        of the vibrating modes. See Martin Keane, 'Understanding
        the complex nature of the piano tone', 2004, for a discussion
        and the source of the mode frequency stretching algorithms 
        implemented here.

        """
        return _loris.Channelizer_setStretchFactor(self, stretch)

    @staticmethod
    def computeStretchFactor(fm, m, fn, n):
        r"""
        computeStretchFactor(fm, m, fn, n) -> double
        the stretching factor used to account for (consistently) 
        detuned harmonics, as in a piano tone, from a pair of 
        mode (harmonic) frequencies and numbers.

        The stretching factor is a small positive number for 
        heavy vibrating strings (as in pianos) for which the
        mass of the string significantly affects the frequency
        of the vibrating modes. See Martin Keane, 'Understanding
        the complex nature of the piano tone', 2004, for a discussion
        and the source of the mode frequency stretching algorithms 
        implemented here.

        The stretching factor is computed using computeStretchFactor,
        but only a valid stretch factor will ever be assigned. If an
        invalid (negative) stretching factor is computed for the
        specified frequencies and mode numbers, the stretch factor
        will be set to zero.

            fm is the frequency of the Mth stretched harmonic

            m is the harmonic number of the harmonic whose frequnecy is fm

            fn is the frequency of the Nth stretched harmonic

            n is the harmonic number of the harmonic whose frequnecy is fn

            returns    the stretching factor, usually a very small positive
            floating point number, or 0 for pefectly tuned harmonics
            (that is, if fn = n*f1).

            Use as argument to Channelizer.setStretchFactor()


        """
        return _loris.Channelizer_computeStretchFactor(fm, m, fn, n)

# Register Channelizer in _loris:
_loris.Channelizer_swigregister(Channelizer)



